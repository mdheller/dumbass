{"version":3,"sources":["common.js","../../../usr/lib/node_modules/parcel/node_modules/base64-js/index.js","../../../usr/lib/node_modules/parcel/node_modules/ieee754/index.js","../../../usr/lib/node_modules/parcel/node_modules/isarray/index.js","../../../usr/lib/node_modules/parcel/node_modules/buffer/index.js","t.js","types.js","r.js"],"names":["CODE","Math","random","BROWSER_SIDE","self","DOMParser","e","BuiltIns","Symbol","Boolean","Number","String","Object","Set","Map","WeakMap","WeakSet","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8ClampedArray","Node","NodeList","Element","HTMLElement","Blob","ArrayBuffer","FileList","Text","Document","DocumentFragment","Error","File","Event","EventTarget","URL","Buffer","isNone","instance","undefined","typeCache","T","parts","vals","cooked","typeName","reduce","prev","cur","i","has","TypeError","Type","validate","type","guardType","guardExists","name","get","spec","kind","verify","sealed","bigErrors","allValid","keyPaths","keys","every","kp","lookup","resolved","lookupErrors","errors","push","length","valid","validationErrors","verified","sealValid","allKeyPaths","sort","join","container","containerValid","containerErrors","membersValid","member","check","obj","keyPath","split","pathComplete","nextKey","shift","error","option","sub","defSub","def","exists","guardRedefinition","o","recurseObject","keyPathSet","lastLevel","levelKeys","getOwnPropertyNames","levelKeyPaths","map","k","forEach","add","v","Array","isArray","defOption","isUnset","defCollection","set","defTuple","pattern","specObj","key","defineProperty","or","defOr","types","some","t","guard","originalName","mapBuiltins","constructor","defineSpecials","Function","isInteger","iterator","oName","prototype","toString","call","replace","endsWith","assign","for","TKey","THandlers","eventNames","handlerFuncs","values","validNames","validFuncs","func","TFuncArray","TEmptyArray","TMarkupObject","code","nodes","externals","TMarkupAttrObject","str","TBrutalLikeObject","to","update","TBrutalObject","TBrutalArray","TSBrutalObject","handlers","TSBrutalArray","BS","SSR","Types","skip","markup","attrskip","attrmarkup","DEBUG","NULLFUNC","KEYMATCH","ATTRMATCH","KEYLEN","OURPROPS","XSS","OBJ","UNSET","INSERT","NOTFOUND","loc","MOVE","frag","elem","appendChild","parentNode","insertBefore","nextSibling","replaceChild","firstChild","innerHTML","onerror","console","log","message","stack","isKey","isHandlers","cache","d","R","u","X","p","dumbass","useCache","instanceKey","cacheKey","guardAndTransformVal","find","isCached","cached","firstCall","vmap","V","replaceValWithKeyAndOmitInstanceKey","toDOM","walker","document","createTreeWalker","NodeFilter","SHOW_ALL","makeUpdaters","nextNode","retVal","childNodes","instances","location","options","position","createDocumentFragment","n","querySelector","die","node","currentNode","nodeType","ELEMENT_NODE","handleElement","COMMENT_NODE","TEXT_NODE","handleNode","result","lengths","text","nodeValue","index","val","replacer","makeNodeUpdater","replacers","exec","nodeState","scope","oldVal","oldNodes","lastAnchor","newVal","getType","handleMarkupInNode","handleTextInNode","state","from","reverse","placeholderNode","summonPlaceholder","dn","diffNodes","size","f","valIndex","vi","originalLengthBefore","slice","lengthBefore","sum","x","value","correction","newValue","getAttributes","attrState","prepareAttributeUpdater","updateName","input","oldName","makeAttributeNameUpdater","makeAttributeValueUpdater","oldLengths","attr","hasAttribute","removeAttribute","trim","test","assignmentIndex","indexOf","reliablySetAttribute","updateAttrWithFuncarrayValue","updateAttrWithFunctionValue","updateAttrWithHandlersValue","updateAttrWithTextValue","nodesToStr","setAttribute","formatClassListValue","getAttribute","attributes","attrs","flags","includes","O","removeEventListener","addEventListener","splice","of","entries","eventName","funcVal","zeroWidthCorrection","newAttrValue","before","after","spacer","JSON","stringify","sibling","ph","guardEmptyHandlers","padEnd","parseFromString","head","firstElementChild","content","normalize","isFunc","isObject","isBrutalArray","isFuncArray","isMarkupObject","isMarkupAttrObject","isBrutal","isForgery","os","bigNodes","cloneNode","createElement","last","next","filter","newVals","msg","err","warn","s","showNodes","info","out","nodeName","toLowerCase","children","innerText"],"mappings":"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","file":"r.js","sourceRoot":"..","sourcesContent":["// common for all r submodules\n  export const CODE              = ''+Math.random();\n\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","\n  export const BROWSER_SIDE      = (() => {try{ return self.DOMParser && true; } catch(e) { return false; }})();\n\n  const BuiltIns = [\n    Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n    Int8Array, Int16Array, Int32Array, \n    Uint8ClampedArray, \n    ...(BROWSER_SIDE ? [\n      Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n      FileList, Text, Document, DocumentFragment,\n      Error, File, Event, EventTarget, URL\n    ] : [ Buffer ])\n  ];\n\n  const isNone = instance => instance == null || instance == undefined;\n\n  const typeCache = new Map();\n\n  Object.assign(T, {check, sub, verify, validate, def, defSub, defTuple, defCollection, defOr, option, defOption, or, guard, errors});\n  \n  T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n  defineSpecials();\n  mapBuiltins();\n\n  export function T(parts, ...vals) {\n    const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n    const typeName = cooked;\n    if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n    return new Type(typeName);\n  }\n\n  function validate(type, instance) {\n    guardType(type);\n    guardExists(type);\n    let typeName = type.name;\n\n    const {spec,kind,verify,sealed} = typeCache.get(typeName);\n\n    const bigErrors = [];\n\n    switch(kind) {\n      case \"def\": {\n        let allValid = true;\n        if ( !! spec ) {\n          const keyPaths = Object.keys(spec);\n          allValid = !isNone(instance) && keyPaths.every(kp => {\n            const {resolved, errors:lookupErrors} = lookup(instance,kp);\n            bigErrors.push(...lookupErrors);\n            if ( lookupErrors.length ) return false;\n            const {valid, errors: validationErrors} = validate(spec[kp], resolved);\n            bigErrors.push(...validationErrors);\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( !!verify ) {\n          try {\n            verified = verify(instance);\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        let sealValid = true;\n        if ( !!sealed ) {\n          const all_key_paths = allKeyPaths(instance).sort().join(',');\n          const type_key_paths = Object.keys(spec).sort().join(',');\n          sealValid  = all_key_paths == type_key_paths;\n        }\n        return {valid: allValid && verified && sealValid, errors: bigErrors}\n      } case \"defCollection\": {\n        const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n        bigErrors.push(...containerErrors);\n        let membersValid = true;\n        if ( containerValid ) {\n           membersValid= [...instance].every(member => {\n            const {valid, errors} = validate(spec.member, member);\n            bigErrors.push(...errors);\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( !!verify ) {\n          try {\n            verified = verify(instance);\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        return {valid:containerValid && membersValid && verified, errors:bigErrors};\n      } default: {\n        throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n      }\n    }\n  }\n\n  function check(...args) {\n    return validate(...args).valid;\n  }\n\n  function lookup(obj, keyPath) {\n    if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n    if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n    const keys = keyPath.split(/\\./g);\n    const pathComplete = [];\n    const errors = [];\n\n    let resolved = obj;\n\n    while(keys.length) {\n      const nextKey = keys.shift();\n      resolved = resolved[nextKey];\n      pathComplete.push(nextKey);\n      if ( keys.length && resolved == null || resolved == undefined ) {\n        errors.push( { error: `Lookup on key path ${keyPath} failed at ${pathComplete.join('.')}\n          when null or undefined was found.` });\n        break;\n      }\n    }\n    return {resolved,errors};\n  }\n\n  function option(type) {\n    return T`?${type.name}`;\n  }\n\n  function sub(type) {\n    return T`>${type.name}`;\n  }\n\n  function defSub(type, spec, {verify} = {}) {\n    guardType(type);\n    guardExists(type);\n    return def(`>${type.name}`, spec, {verify});\n  }\n\n  function exists(name) {\n    return typeCache.has(name);\n  }\n\n  function guardRedefinition(name) {\n    if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n  }\n\n  function allKeyPaths(o) {\n    const keyPaths = new Set();\n    return recurseObject(o, keyPaths);\n\n    // how to do this?\n    // notes:\n      // i think we ignore any array properties for now, since unless we had some\n      // notion of 'fixed size' (which we could do via a collection type verify function)\n      // arrays can be dynamicly sized, so taking the indices as keys is not\n      // easily expressible in a representation of a type definition that we can check against\n      // so we only care about key names and object properties. \n      // we need a stack. Or a recursive function, that takes a set as an argument\n      // also we ignore keys inherited from prototypes so this is also another limitation\n      // but probably also a desirable feature of this implementation // notion of sealed\n      // since that means that instead of having to worry about a possibly unbounded definition\n      // of other key paths inherited through prototypes of other types\n      // sealed only applies to checking the properties on this object that are set on itself. \n\n    function recurseObject(o, keyPathSet, lastLevel = '') {\n      const levelKeys = Object.getOwnPropertyNames(o); \n      const levelKeyPaths = levelKeys.map( k => lastLevel + k );\n      levelKeyPaths.forEach(kp => keyPathSet.add(kp));\n      for ( const k of levelKeys ) {\n        const v = o[k];\n        if ( typeof v == \"object\" && ! Array.isArray(v) ) {\n          recurseObject(v, lastLevel+k, keyPathSet);\n        }\n      }\n      return [...keyPathSet];\n    }\n  }\n\n  function defOption(type) {\n    guardType(type);\n    const typeName = type.name;\n    return T.def(`?${typeName}`, null, {verify: i => isUnset(i) || T.check(type,i)});\n  }\n\n  function verify(...args) { return check(...args); }\n\n  function defCollection(name, {container, member}, {sealed,verify} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n    guardRedefinition(name);\n\n    const kind = 'defCollection';\n    const spec = {kind, spec: { container, member}, verify, sealed};\n    typeCache.set(name, spec);\n    return new Type(name);\n  }\n\n  function defTuple(name, {pattern}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !pattern ) throw new TypeError(`Type must be specified.`);\n    const kind = 'def';\n    const specObj = {};\n    pattern.forEach((type,key) => specObj[key] = type);\n    const spec = {kind, spec: specObj};\n    typeCache.set(name, spec);\n    return new Type(name);\n  }\n\n  function Type(name, mods = {}) {\n    if ( ! new.target ) throw new TypeError(`Type with new only.`);\n    Object.defineProperty(this,'name', {get: () => name});\n    this.typeName = name;\n  }\n\n  Type.prototype.toString = function () {\n    return `${this.name} Type`;\n  };\n\n  function def(name, spec, {verify, sealed} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n\n    const kind = 'def';\n    typeCache.set(name, {spec,kind,verify, sealed});\n    return new Type(name);\n  }\n\n  function or(...types) { // anonymous standin for defOr\n    // could we do this with `name|name2|...` etc ?  we have to sort names so probably can\n    throw new TypeError(`Or is not implemented yet.`);\n  }\n\n  function defOr(name, ...types) {\n    return T.def(name, null, {verify: i => types.some(t => check(t,i))});\n  }\n\n  function guard(type, instance) {\n    guardType(type);\n    guardExists(type);\n    const {valid, errors} = validate(type, instance);\n    if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n  }\n\n  function guardType(t) {\n    if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n  }\n\n  function guardExists(t) {\n    const name = originalName(t);\n    if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n  }\n\n  function errors(...args) {\n    return validate(...args).errors;\n  }\n\n  function mapBuiltins() {\n    BuiltIns.forEach(t => def(originalName(t), null, {verify: i => originalName(i.constructor) === originalName(t)}));  \n    BuiltIns.forEach(t => defSub(T`${originalName(t)}`, null, {verify: i => i instanceof t}));  \n  }\n\n  function defineSpecials() {\n    T.def(`Any`, null, {verify: i => true});\n    T.def(`Some`, null, {verify: i => !isUnset(i)});\n    T.def(`None`, null, {verify: i => isUnset(i)});\n    T.def(`Function`, null, {verify: i => i instanceof Function});\n    T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n    T.def(`Array`, null, {verify: i => Array.isArray(i)});\n    T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n  }\n\n  function isUnset(i) {\n    return i === null || i === undefined;\n  }\n\n  function originalName(t) {\n    if (!!t && t.name) {\n      return t.name;\n    } \n    const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n    if ( oName.endsWith('Constructor') ) {\n      return oName.replace(/Constructor$/,'');\n    }\n    return oName;\n  }\n\n","// types\n  import {T} from './t.js';\n  import {CODE} from './common.js';\n\n  // T\n\n    export default T;\n\n  // Both SSR and Browser\n\n    export const TKey = T.def('Key', {\n      key: T.defOr('ValidKey', T`String`, T`Number`)\n    });\n\n    export const THandlers = T.def('Handlers', null, {verify: i => {\n      const validObject = T.check(T`Object`, i);\n\n      if ( ! validObject ) return false;\n\n      const eventNames = Object.keys(i);\n      const handlerFuncs = Object.values(i);\n      const validNames = eventNames.every(name => T.check(T`String`, name));\n      const validFuncs = handlerFuncs.every(func => T.check(T`Function`, func));\n      const valid = validNames && validFuncs;\n\n      return valid;\n    }});\n\n    export const TFuncArray = T.defCollection('FuncArray', {\n      container: T`Array`,\n      member: T`Function`\n    });\n\n    export const TEmptyArray = T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n    export const TMarkupObject = T.def('MarkupObject', {\n      type: T`String`,\n      code: T`String`,\n      nodes: T`Array`,\n      externals: T`Array`,\n    }, {verify: v => v.type == 'MarkupObject' && v.code == CODE});\n\n    export const TMarkupAttrObject = T.def('MarkupAttrObject', {\n      type: T`String`,\n      code: T`String`,\n      str: T`String`\n    }, {verify: v => v.type == 'MarkupAttrObject' && v.code == CODE});\n\n  // Browser side\n\n    export const TBrutalLikeObject = T.def('BrutalLikeObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`\n    });\n\n    export const TBrutalObject = T.def('BrutalObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`\n    }, {verify: v => verify(v)});\n\n    export const TBrutalArray = T.defCollection('BrutalArray', {\n      container: T`Array`,\n      member: T`BrutalObject`\n    });\n\n  // SSR\n\n    export const TSBrutalObject = T.def('SBrutalObject', {\n      str: T`String`,\n      handlers: THandlers\n    });\n\n    export const TSBrutalArray = T.defCollection('SBrutalArray', {\n      container: T`Array`,\n      member: T`SBrutalObject`\n    });\n\n  // export\n\n  export const BS = {TKey,THandlers,TFuncArray,TBrutalObject,TBrutalLikeObject,TBrutalArray};\n\n  export const SSR = {TKey,THandlers,TFuncArray,TSBrutalObject,TSBrutalArray};\n\n  export const Types = {BS,SSR};\n\n\n  // verify function \n    function verify(v) {\n      return CODE === v.code;\n    }\n\n","// r.js\n  // imports\n    import {CODE} from './common.js';\n    import T from './types.js';\n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = false;\n    const NULLFUNC          = () => void 0;\n    const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n    const ATTRMATCH         = /\\w+=/;\n    const KEYLEN            = 20;\n    const OURPROPS          = 'code,externals,nodes,to,update,v';\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = () => `Object values not allowed here.`;\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforeBegin, afterBegin, beforeEnd, innerHTML, afterEnd`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeEnd   (frag,elem) { elem.appendChild(frag) }\n      beforeBegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterEnd    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterBegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerHTML   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag) }\n    };\n\n  // logging\n    self.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => T.check(T`Key`, v);\n    const isHandlers        = v => T.check(T`Handlers`, v);\n\n  // cache \n    const cache = {};\n    export const d = R;\n    export const u = X;\n\n  // main exports \n    Object.assign(R,{s,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n    if ( DEBUG ) {\n      Object.assign(self, {d,u,T}); \n    }\n\n    export function R(p,...v) {\n      return dumbass(p,v);\n    }\n\n    export function X(p,...v) {\n      return dumbass(p,v,{useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function dumbass(p,v,{useCache:useCache=true}={}) {\n      let instanceKey, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        ({key:instanceKey} = (v.find(isKey) || {}));\n        cacheKey = p.join('<link rel=join>');\n        const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        }\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = '';\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      const retVal = {externals,v:Object.values(vmap),to,\n        update,code:CODE,nodes:[...frag.childNodes]};\n\n      if ( useCache ) {\n        if ( !! instanceKey ) {\n          cache[cacheKey].instances[instanceKey] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n      }\n\n      return retVal;\n    }\n\n  // to function\n    function to(location, options) {\n      const position = options || 'replace';\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const elem = T.check(T`>Node`, location) ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);\n          case \"TypeError\":         die({error: NOTFOUND(location)},e); \n          default: throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result;\n      while( result = KEYMATCH.exec(text) ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        externals.push(() => replacer(val.val));\n        val.replacers.push( replacer );\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"markupobject\": \n            case \"brutalobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( !! newVal.nodes.length ) {\n          Array.from(newVal.nodes).reverse().forEach(n => {\n            lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n            state.lastAnchor = lastAnchor.nextSibling;\n          });\n          state.lastAnchor = newVal.nodes[0];\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          dn.forEach(n => f.appendChild(n));\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function handleElement({node,vmap,externals} = {}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n          let result;\n          while( result = KEYMATCH.exec(name) ) prepareAttributeUpdater(result, attrState, {updateName:true});\n          while( result = KEYMATCH.exec(value) ) prepareAttributeUpdater(result, attrState, {updateName:false});\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,updateName,node,input,index,name,val,externals,lengths,oldLengths} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : ''\n          if ( attr !== newVal ) {\n            if ( !! attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( !! newVal ) {\n              newVal = newVal.trim();\n              let result;\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"markupobject\":     \n            case \"brutalobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n          }\n        };\n      }\n\n  // helpers\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,updateName,node,input,index,name,val,externals,lengths,oldLengths} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( !! oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n      } else {\n        if ( !! oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,updateName,node,input,index,name,val,externals,lengths,oldLengths} = scope;\n      if ( !! oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( !! oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( !! oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,updateName,node,input,index,name,val,externals,lengths,oldLengths} = scope;\n      if ( !!oldVal && T.check(T`Handlers`, oldVal) ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            console.log(eventName, funcVal, flags);\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,updateName,node,input,index,name,val,externals,lengths,oldLengths} = scope;\n      let zeroWidthCorrection = 0;\n      const valIndex = val.vi;\n      const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        \n      // we need to trim newVal to have parity with classlist add\n        // the reason we have zeroWidthCorrection = -1\n        // is because the classList is a set of non-zero width tokens\n        // separated by spaces\n        // when we have a zero width token, we have two adjacent spaces\n        // which, by virtue of our other requirement, gets replaced by a single space\n        // effectively elliding out our replacement location\n        // in order to keep our replacement location in tact\n        // we need to compensate for the loss of a token slot (effectively a token + a space)\n        // and having a -1 correction effectively does this.\n      if ( name == \"class\" ) {\n        newVal = newVal.trim();\n        if ( newVal.length == 0 ) {\n          zeroWidthCorrection = -1;\n        }\n        scope.val.val = newVal;\n      }\n      lengths[valIndex] = newVal.length + zeroWidthCorrection;\n      let attr = node.getAttribute(name);\n\n      const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n      const correction = lengthBefore-originalLengthBefore;\n      const before = attr.slice(0,index+correction);\n      const after = attr.slice(index+correction+oldVal.length);\n\n      let newAttrValue;\n      \n      if ( name == \"class\" ) {\n        const spacer = oldVal.length == 0 ? ' ' : '';\n        newAttrValue = before + spacer + newVal + spacer + after;\n      } else {\n        newAttrValue = before + newVal + after;\n      }\n\n      DEBUG && console.log(JSON.stringify({\n        newVal,\n        valIndex,\n        lengths,\n        attr,\n        lengthBefore,\n        originalLengthBefore,\n        correction,\n        before,\n        after,\n        newAttrValue\n      }, null, 2));\n\n      reliablySetAttribute(node, name, newAttrValue);\n\n      scope.oldVal = newVal;\n    }\n\n    function reliablySetAttribute(node, name, value ) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n      node.setAttribute(name,value);\n      try {\n        node[name] = value == undefined ? true : value;\n      } catch(e) {}\n    }\n\n    function getType(val) {\n      const type = T.check(T`Function`, val) ? 'function' :\n        T.check(T`Handlers`, val) ? 'handlers' : \n        T.check(T`BrutalObject`, val) ? 'brutalobject' : \n        T.check(T`MarkupObject`, val) ? 'markupobject' :\n        T.check(T`MarkupAttrObject`, val) ? 'markupattrobject' :\n        T.check(T`FuncArray`, val) ? 'funcarray' : 'default';\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'brutal-placeholder' );\n      if ( ! ph ) {\n        ph = toDOM(`<!--brutal-placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instanceKey) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( !! instanceKey ) {\n            cached.instances = {};\n            cached = cached.instances[instanceKey] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( !! instanceKey ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instanceKey];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                firstCall = false;\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that Brutal treats as markup,\n      // even tho it is NOT a Brutal Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:CODE,\n          nodes:[...frag.childNodes],\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that Brutal treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( T.check(T`None`, val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( T.check(T`Key`, val) ) {\n            return '';\n          }\n          const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n          let k = key;\n          if ( T.check(T`BrutalObject`, val) || T.check(T`MarkupObject`, val) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key.trim()] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        const f = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\"text/html\").head.firstElementChild.content;\n        f.normalize();\n        return f;\n      }\n\n      function guardAndTransformVal(v) {\n        const isFunc          = T.check(T`Function`, v);\n        const isUnset         = T.check(T`None`, v);\n        const isObject        = T.check(T`Object`, v);\n        const isBrutalArray   = T.check(T`BrutalArray`, v);\n        const isFuncArray     = T.check(T`FuncArray`, v);\n        const isMarkupObject    = T.check(T`MarkupObject`, v);\n        const isMarkupAttrObject= T.check(T`MarkupAttrObject`, v);\n        const isBrutal        = T.check(T`BrutalObject`, v);\n        const isForgery       = T.check(T`BrutalLikeObject`, v)  && !isBrutal; \n\n        if ( isFunc )         return v;\n        if ( isBrutal )       return v;\n        if ( isKey(v) )       return v;\n        if ( isHandlers(v) )  return v;\n        if ( isBrutalArray )  return join(v); \n        if ( isFuncArray )    return v;\n        if ( isMarkupObject )   return v;\n        if ( isMarkupAttrObject)return v;\n        if ( isUnset )        die({error: UNSET()});\n        if ( isForgery )      die({error: XSS()});\n        if ( isObject )       die({error: OBJ()});\n\n        return v+'';\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        os.forEach(o => (externals.push(...o.externals),bigNodes.push(...o.nodes)));\n        //Refers #45. Debug to try to see when node reverse order is introduced.\n        //setTimeout( () => console.log(nodesToStr(bigNodes)), 1000 );\n        const retVal = {v:[],code:CODE,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        this.v.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      if (DEBUG && err) console.warn(err);\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw JSON.stringify(msg,null,2);\n    }\n\n    function s(msg) {\n      if ( DEBUG ) {\n        console.log(JSON.stringify(msg,showNodes,2));\n        console.info('.');\n      }\n    }\n\n    function showNodes(k,v) {\n      let out = v;\n      if ( T.check(T`>Node`, v) ) {\n        out = `<${v.nodeName.toLowerCase()} ${\n          !v.attributes ? '' : [...v.attributes].map(({name,value}) => `${name}='${value}'`).join(' ')}>${\n          v.nodeValue || (v.children && v.children.length <= 1 ? v.innerText : '')}`;\n      } else if ( typeof v === \"function\" ) {\n        return `${v.name || 'anon'}() { ... }`\n      }\n      return out;\n    }\n"]}